{"ast":null,"code":"import _regeneratorRuntime from \"D:/React Native/Rainbow-Chimera/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"D:/React Native/Rainbow-Chimera/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"D:/React Native/Rainbow-Chimera/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { InterlaceOffsets, InterlaceSteps } from \"./Constants\";\nimport { ByteStream } from \"./ByteStream\";\nfunction parseColorTable(byteStream, count) {\n  var colors = [];\n  for (var i = 0; i < count; i++) {\n    colors.push({\n      r: byteStream.data[byteStream.pos],\n      g: byteStream.data[byteStream.pos + 1],\n      b: byteStream.data[byteStream.pos + 2]\n    });\n    byteStream.pos += 3;\n  }\n  return colors;\n}\nfunction parseExtensionBlock(_x, _x2, _x3, _x4) {\n  return _parseExtensionBlock.apply(this, arguments);\n}\nfunction _parseExtensionBlock() {\n  _parseExtensionBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(byteStream, gif, getFrameIndex, getTransparencyIndex) {\n    var frame, packedByte, transparencyFlag, transparencyIndex, applicationExtension;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = byteStream.nextByte();\n          _context.next = _context.t0 === 249 ? 3 : _context.t0 === 255 ? 15 : _context.t0 === 254 ? 19 : _context.t0 === 1 ? 21 : 26;\n          break;\n        case 3:\n          frame = gif.frames[getFrameIndex(false)];\n          byteStream.pos++;\n          packedByte = byteStream.nextByte();\n          frame.GCreserved = (packedByte & 0xe0) >>> 5;\n          frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n          frame.userInputDelayFlag = (packedByte & 2) === 2;\n          transparencyFlag = (packedByte & 1) === 1;\n          frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n          transparencyIndex = byteStream.nextByte();\n          if (transparencyFlag) {\n            getTransparencyIndex(transparencyIndex);\n          }\n          byteStream.pos++;\n          return _context.abrupt(\"break\", 28);\n        case 15:\n          byteStream.pos++;\n          applicationExtension = {\n            identifier: byteStream.getString(8),\n            authenticationCode: byteStream.getString(3),\n            data: byteStream.readSubBlocksBin()\n          };\n          gif.applicationExtensions.push(applicationExtension);\n          return _context.abrupt(\"break\", 28);\n        case 19:\n          gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\n          return _context.abrupt(\"break\", 28);\n        case 21:\n          if (!(gif.globalColorTable.length === 0)) {\n            _context.next = 23;\n            break;\n          }\n          throw new EvalError(\"plain text extension without global color table\");\n        case 23:\n          byteStream.pos++;\n          gif.frames[getFrameIndex(false)].plainTextData = {\n            left: byteStream.nextTwoBytes(),\n            top: byteStream.nextTwoBytes(),\n            width: byteStream.nextTwoBytes(),\n            height: byteStream.nextTwoBytes(),\n            charSize: {\n              width: byteStream.nextTwoBytes(),\n              height: byteStream.nextTwoBytes()\n            },\n            foregroundColor: byteStream.nextByte(),\n            backgroundColor: byteStream.nextByte(),\n            text: byteStream.readSubBlocks()\n          };\n          return _context.abrupt(\"break\", 28);\n        case 26:\n          byteStream.skipSubBlocks();\n          return _context.abrupt(\"break\", 28);\n        case 28:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _parseExtensionBlock.apply(this, arguments);\n}\nfunction parseImageBlock(_x5, _x6, _x7, _x8, _x9, _x10) {\n  return _parseImageBlock.apply(this, arguments);\n}\nfunction _parseImageBlock() {\n  _parseImageBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    var frame, packedByte, localColorTableFlag, interlacedFlag, localColorCount, getColor, image, minCodeSize, imageData, clearCode, readBits, code, size, pos, dic, pass, pixelPos, lineIndex, last, i, _i, _getColor, r, g, b, a, _code, _size, _pos, _dic, _pixelPos, _last, _i2, _i3, _getColor2, _r, _g, _b, _a;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          frame = gif.frames[getFrameIndex(true)];\n          frame.left = byteStream.nextTwoBytes();\n          frame.top = byteStream.nextTwoBytes();\n          frame.width = byteStream.nextTwoBytes();\n          frame.height = byteStream.nextTwoBytes();\n          packedByte = byteStream.nextByte(), localColorTableFlag = (packedByte & 0x80) === 0x80, interlacedFlag = (packedByte & 0x40) === 0x40;\n          frame.sortFlag = (packedByte & 0x20) === 0x20;\n          frame.reserved = (packedByte & 0x18) >>> 3;\n          localColorCount = 1 << (packedByte & 7) + 1;\n          if (localColorTableFlag) {\n            frame.localColorTable = parseColorTable(byteStream, localColorCount);\n          }\n          getColor = function getColor(index) {\n            var _index = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index],\n              r = _index.r,\n              g = _index.g,\n              b = _index.b;\n            return {\n              r: r,\n              g: g,\n              b: b,\n              a: index === getTransparencyIndex(null) ? avgAlpha ? ~~((r + g + b) / 3) : 0 : 255\n            };\n          };\n          image = function () {\n            try {\n              return new ImageData(frame.width, frame.height, {\n                colorSpace: \"srgb\"\n              });\n            } catch (error) {\n              if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n              }\n              throw error;\n            }\n          }();\n          if (!(image == null)) {\n            _context2.next = 14;\n            break;\n          }\n          throw new EvalError(\"GIF frame size is to large\");\n        case 14:\n          minCodeSize = byteStream.nextByte(), imageData = byteStream.readSubBlocksBin(), clearCode = 1 << minCodeSize;\n          readBits = function readBits(pos, len) {\n            var bytePos = pos >>> 3,\n              bitPos = pos & 7;\n            return (imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16) & (1 << len) - 1 << bitPos) >>> bitPos;\n          };\n          if (!interlacedFlag) {\n            _context2.next = 41;\n            break;\n          }\n          code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0;\n        case 18:\n          if (!(pass < 4)) {\n            _context2.next = 35;\n            break;\n          }\n          if (!(InterlaceOffsets[pass] < frame.height)) {\n            _context2.next = 31;\n            break;\n          }\n          pixelPos = 0, lineIndex = 0;\n        case 21:\n          last = code;\n          code = readBits(pos, size);\n          pos += size + 1;\n          if (code === clearCode) {\n            size = minCodeSize + 1;\n            dic.length = clearCode + 2;\n            for (i = 0; i < dic.length; i++) {\n              dic[i] = i < clearCode ? [i] : [];\n            }\n          } else {\n            if (code >= dic.length) {\n              dic.push(dic[last].concat(dic[last][0]));\n            } else if (last !== clearCode) {\n              dic.push(dic[last].concat(dic[code][0]));\n            }\n            for (_i = 0; _i < dic[code].length; _i++) {\n              _getColor = getColor(dic[code][_i]), r = _getColor.r, g = _getColor.g, b = _getColor.b, a = _getColor.a;\n              image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width + InterlaceSteps[pass] * lineIndex + pixelPos % (frame.width * 4));\n              pixelPos += 4;\n            }\n            if (dic.length === 1 << size && size < 0xc) {\n              size++;\n            }\n          }\n          if (!(pixelPos === frame.width * 4 * (lineIndex + 1))) {\n            _context2.next = 29;\n            break;\n          }\n          lineIndex++;\n          if (!(InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height)) {\n            _context2.next = 29;\n            break;\n          }\n          return _context2.abrupt(\"break\", 31);\n        case 29:\n          _context2.next = 21;\n          break;\n        case 31:\n          progressCallback === null || progressCallback === void 0 || progressCallback(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, {\n            x: frame.left,\n            y: frame.top\n          }, {\n            width: gif.width,\n            height: gif.height\n          });\n        case 32:\n          pass++;\n          _context2.next = 18;\n          break;\n        case 35:\n          frame.image = image;\n          _context2.next = 38;\n          return createImageBitmap(image);\n        case 38:\n          frame.bitmap = _context2.sent;\n          _context2.next = 63;\n          break;\n        case 41:\n          _code = 0, _size = minCodeSize + 1, _pos = 0, _dic = [[0]], _pixelPos = -4;\n        case 42:\n          _last = _code;\n          _code = readBits(_pos, _size);\n          _pos += _size;\n          if (!(_code === clearCode)) {\n            _context2.next = 51;\n            break;\n          }\n          _size = minCodeSize + 1;\n          _dic.length = clearCode + 2;\n          for (_i2 = 0; _i2 < _dic.length; _i2++) {\n            _dic[_i2] = _i2 < clearCode ? [_i2] : [];\n          }\n          _context2.next = 56;\n          break;\n        case 51:\n          if (!(_code === clearCode + 1)) {\n            _context2.next = 53;\n            break;\n          }\n          return _context2.abrupt(\"break\", 58);\n        case 53:\n          if (_code >= _dic.length) {\n            _dic.push(_dic[_last].concat(_dic[_last][0]));\n          } else if (_last !== clearCode) {\n            _dic.push(_dic[_last].concat(_dic[_code][0]));\n          }\n          for (_i3 = 0; _i3 < _dic[_code].length; _i3++) {\n            _getColor2 = getColor(_dic[_code][_i3]), _r = _getColor2.r, _g = _getColor2.g, _b = _getColor2.b, _a = _getColor2.a;\n            image.data.set([_r, _g, _b, _a], _pixelPos += 4);\n          }\n          if (_dic.length >= 1 << _size && _size < 0xc) {\n            _size++;\n          }\n        case 56:\n          _context2.next = 42;\n          break;\n        case 58:\n          frame.image = image;\n          _context2.next = 61;\n          return createImageBitmap(image);\n        case 61:\n          frame.bitmap = _context2.sent;\n          progressCallback === null || progressCallback === void 0 || progressCallback((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, {\n            x: frame.left,\n            y: frame.top\n          }, {\n            width: gif.width,\n            height: gif.height\n          });\n        case 63:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _parseImageBlock.apply(this, arguments);\n}\nfunction parseBlock(_x11, _x12, _x13, _x14, _x15, _x16) {\n  return _parseBlock.apply(this, arguments);\n}\nfunction _parseBlock() {\n  _parseBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.t0 = byteStream.nextByte();\n          _context3.next = _context3.t0 === 59 ? 3 : _context3.t0 === 44 ? 4 : _context3.t0 === 33 ? 7 : 10;\n          break;\n        case 3:\n          return _context3.abrupt(\"return\", true);\n        case 4:\n          _context3.next = 6;\n          return parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n        case 6:\n          return _context3.abrupt(\"break\", 11);\n        case 7:\n          _context3.next = 9;\n          return parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n        case 9:\n          return _context3.abrupt(\"break\", 11);\n        case 10:\n          throw new EvalError(\"undefined block found\");\n        case 11:\n          return _context3.abrupt(\"return\", false);\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _parseBlock.apply(this, arguments);\n}\nexport function getGIFLoopAmount(gif) {\n  var _iterator = _createForOfIteratorHelper(gif.applicationExtensions),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var extension = _step.value;\n      if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n        continue;\n      }\n      return extension.data[1] + (extension.data[2] << 8);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return NaN;\n}\nexport function decodeGIF(_x17, _x18, _x19) {\n  return _decodeGIF.apply(this, arguments);\n}\nfunction _decodeGIF() {\n  _decodeGIF = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(gifURL, progressCallback, avgAlpha) {\n    var res, buffer, gif, byteStream, packedByte, globalColorTableFlag, globalColorCount, backgroundColorIndex, backgroundImage, _gif$globalColorTable, r, g, b, i, frameIndex, incrementFrameIndex, transparencyIndex, getframeIndex, getTransparencyIndex, _iterator2, _step2, _frame;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          if (!avgAlpha) avgAlpha = false;\n          _context4.next = 3;\n          return fetch(gifURL);\n        case 3:\n          res = _context4.sent;\n          if (!(!res.ok && res.status === 404)) {\n            _context4.next = 6;\n            break;\n          }\n          throw new EvalError(\"file not found\");\n        case 6:\n          _context4.next = 8;\n          return res.arrayBuffer();\n        case 8:\n          buffer = _context4.sent;\n          gif = {\n            width: 0,\n            height: 0,\n            totalTime: 0,\n            colorRes: 0,\n            pixelAspectRatio: 0,\n            frames: [],\n            sortFlag: false,\n            globalColorTable: [],\n            backgroundImage: new ImageData(1, 1, {\n              colorSpace: \"srgb\"\n            }),\n            comments: [],\n            applicationExtensions: []\n          }, byteStream = new ByteStream(new Uint8ClampedArray(buffer));\n          if (!(byteStream.getString(6) !== \"GIF89a\")) {\n            _context4.next = 12;\n            break;\n          }\n          throw new Error(\"not a supported GIF file\");\n        case 12:\n          gif.width = byteStream.nextTwoBytes();\n          gif.height = byteStream.nextTwoBytes();\n          packedByte = byteStream.nextByte(), globalColorTableFlag = (packedByte & 0x80) === 0x80;\n          gif.colorRes = (packedByte & 0x70) >>> 4;\n          gif.sortFlag = (packedByte & 8) === 8;\n          globalColorCount = 1 << (packedByte & 7) + 1, backgroundColorIndex = byteStream.nextByte();\n          gif.pixelAspectRatio = byteStream.nextByte();\n          if (gif.pixelAspectRatio !== 0) {\n            gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n          }\n          if (globalColorTableFlag) {\n            gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n          }\n          backgroundImage = function () {\n            try {\n              return new ImageData(gif.width, gif.height, {\n                colorSpace: \"srgb\"\n              });\n            } catch (error) {\n              if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n              }\n              throw error;\n            }\n          }();\n          if (!(backgroundImage == null)) {\n            _context4.next = 24;\n            break;\n          }\n          throw new Error(\"GIF frame size is to large\");\n        case 24:\n          _gif$globalColorTable = gif.globalColorTable[backgroundColorIndex], r = _gif$globalColorTable.r, g = _gif$globalColorTable.g, b = _gif$globalColorTable.b;\n          backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\n          for (i = 4; i < backgroundImage.data.length; i *= 2) {\n            backgroundImage.data.copyWithin(i, 0, i);\n          }\n          gif.backgroundImage = backgroundImage;\n          frameIndex = -1, incrementFrameIndex = true, transparencyIndex = -1;\n          getframeIndex = function getframeIndex(increment) {\n            if (increment) {\n              incrementFrameIndex = true;\n            }\n            return frameIndex;\n          };\n          getTransparencyIndex = function getTransparencyIndex(newValue) {\n            if (newValue != null) {\n              transparencyIndex = newValue;\n            }\n            return transparencyIndex;\n          };\n          _context4.prev = 31;\n        case 32:\n          if (incrementFrameIndex) {\n            gif.frames.push({\n              left: 0,\n              top: 0,\n              width: 0,\n              height: 0,\n              disposalMethod: 0,\n              image: new ImageData(1, 1, {\n                colorSpace: \"srgb\"\n              }),\n              plainTextData: null,\n              userInputDelayFlag: false,\n              delayTime: 0,\n              sortFlag: false,\n              localColorTable: [],\n              reserved: 0,\n              GCreserved: 0\n            });\n            frameIndex++;\n            transparencyIndex = -1;\n            incrementFrameIndex = false;\n          }\n        case 33:\n          _context4.next = 35;\n          return parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback);\n        case 35:\n          if (!_context4.sent) {\n            _context4.next = 32;\n            break;\n          }\n        case 36:\n          gif.frames.length--;\n          _iterator2 = _createForOfIteratorHelper(gif.frames);\n          _context4.prev = 38;\n          _iterator2.s();\n        case 40:\n          if ((_step2 = _iterator2.n()).done) {\n            _context4.next = 48;\n            break;\n          }\n          _frame = _step2.value;\n          if (!(_frame.userInputDelayFlag && _frame.delayTime === 0)) {\n            _context4.next = 45;\n            break;\n          }\n          gif.totalTime = Infinity;\n          return _context4.abrupt(\"break\", 48);\n        case 45:\n          gif.totalTime += _frame.delayTime;\n        case 46:\n          _context4.next = 40;\n          break;\n        case 48:\n          _context4.next = 53;\n          break;\n        case 50:\n          _context4.prev = 50;\n          _context4.t0 = _context4[\"catch\"](38);\n          _iterator2.e(_context4.t0);\n        case 53:\n          _context4.prev = 53;\n          _iterator2.f();\n          return _context4.finish(53);\n        case 56:\n          return _context4.abrupt(\"return\", gif);\n        case 59:\n          _context4.prev = 59;\n          _context4.t1 = _context4[\"catch\"](31);\n          if (!(_context4.t1 instanceof EvalError)) {\n            _context4.next = 63;\n            break;\n          }\n          throw new Error(\"error while parsing frame \".concat(frameIndex, \" \\\"\").concat(_context4.t1.message, \"\\\"\"));\n        case 63:\n          throw _context4.t1;\n        case 64:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[31, 59], [38, 50, 53, 56]]);\n  }));\n  return _decodeGIF.apply(this, arguments);\n}","map":{"version":3,"names":["InterlaceOffsets","InterlaceSteps","ByteStream","parseColorTable","byteStream","count","colors","i","push","r","data","pos","g","b","parseExtensionBlock","_x","_x2","_x3","_x4","_parseExtensionBlock","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","gif","getFrameIndex","getTransparencyIndex","frame","packedByte","transparencyFlag","transparencyIndex","applicationExtension","wrap","_callee$","_context","prev","next","t0","nextByte","frames","GCreserved","disposalMethod","userInputDelayFlag","delayTime","nextTwoBytes","abrupt","identifier","getString","authenticationCode","readSubBlocksBin","applicationExtensions","comments","readSubBlocks","globalColorTable","length","EvalError","plainTextData","left","top","width","height","charSize","foregroundColor","backgroundColor","text","skipSubBlocks","stop","parseImageBlock","_x5","_x6","_x7","_x8","_x9","_x10","_parseImageBlock","_callee2","avgAlpha","progressCallback","localColorTableFlag","interlacedFlag","localColorCount","getColor","image","minCodeSize","imageData","clearCode","readBits","code","size","dic","pass","pixelPos","lineIndex","last","_i","_getColor","a","_code","_size","_pos","_dic","_pixelPos","_last","_i2","_i3","_getColor2","_r","_g","_b","_a","_callee2$","_context2","sortFlag","reserved","localColorTable","index","_index","ImageData","colorSpace","error","DOMException","name","len","bytePos","bitPos","concat","set","x","y","createImageBitmap","bitmap","sent","parseBlock","_x11","_x12","_x13","_x14","_x15","_x16","_parseBlock","_callee3","_callee3$","_context3","getGIFLoopAmount","_iterator","_createForOfIteratorHelper","_step","s","n","done","extension","value","err","e","f","NaN","decodeGIF","_x17","_x18","_x19","_decodeGIF","_callee4","gifURL","res","buffer","globalColorTableFlag","globalColorCount","backgroundColorIndex","backgroundImage","_gif$globalColorTable","frameIndex","incrementFrameIndex","getframeIndex","_iterator2","_step2","_frame","_callee4$","_context4","fetch","ok","status","arrayBuffer","totalTime","colorRes","pixelAspectRatio","Uint8ClampedArray","Error","copyWithin","increment","newValue","Infinity","finish","t1","message"],"sources":["D:/React Native/Rainbow-Chimera/frontend/node_modules/tsparticles-shape-image/esm/GifUtils/Utils.js"],"sourcesContent":["import { InterlaceOffsets, InterlaceSteps } from \"./Constants\";\r\nimport { ByteStream } from \"./ByteStream\";\r\nfunction parseColorTable(byteStream, count) {\r\n    const colors = [];\r\n    for (let i = 0; i < count; i++) {\r\n        colors.push({\r\n            r: byteStream.data[byteStream.pos],\r\n            g: byteStream.data[byteStream.pos + 1],\r\n            b: byteStream.data[byteStream.pos + 2],\r\n        });\r\n        byteStream.pos += 3;\r\n    }\r\n    return colors;\r\n}\r\nasync function parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex) {\r\n    switch (byteStream.nextByte()) {\r\n        case 249: {\r\n            const frame = gif.frames[getFrameIndex(false)];\r\n            byteStream.pos++;\r\n            const packedByte = byteStream.nextByte();\r\n            frame.GCreserved = (packedByte & 0xe0) >>> 5;\r\n            frame.disposalMethod = (packedByte & 0x1c) >>> 2;\r\n            frame.userInputDelayFlag = (packedByte & 2) === 2;\r\n            const transparencyFlag = (packedByte & 1) === 1;\r\n            frame.delayTime = byteStream.nextTwoBytes() * 0xa;\r\n            const transparencyIndex = byteStream.nextByte();\r\n            if (transparencyFlag) {\r\n                getTransparencyIndex(transparencyIndex);\r\n            }\r\n            byteStream.pos++;\r\n            break;\r\n        }\r\n        case 255: {\r\n            byteStream.pos++;\r\n            const applicationExtension = {\r\n                identifier: byteStream.getString(8),\r\n                authenticationCode: byteStream.getString(3),\r\n                data: byteStream.readSubBlocksBin(),\r\n            };\r\n            gif.applicationExtensions.push(applicationExtension);\r\n            break;\r\n        }\r\n        case 254: {\r\n            gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\r\n            break;\r\n        }\r\n        case 1: {\r\n            if (gif.globalColorTable.length === 0) {\r\n                throw new EvalError(\"plain text extension without global color table\");\r\n            }\r\n            byteStream.pos++;\r\n            gif.frames[getFrameIndex(false)].plainTextData = {\r\n                left: byteStream.nextTwoBytes(),\r\n                top: byteStream.nextTwoBytes(),\r\n                width: byteStream.nextTwoBytes(),\r\n                height: byteStream.nextTwoBytes(),\r\n                charSize: {\r\n                    width: byteStream.nextTwoBytes(),\r\n                    height: byteStream.nextTwoBytes(),\r\n                },\r\n                foregroundColor: byteStream.nextByte(),\r\n                backgroundColor: byteStream.nextByte(),\r\n                text: byteStream.readSubBlocks(),\r\n            };\r\n            break;\r\n        }\r\n        default:\r\n            byteStream.skipSubBlocks();\r\n            break;\r\n    }\r\n}\r\nasync function parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\r\n    const frame = gif.frames[getFrameIndex(true)];\r\n    frame.left = byteStream.nextTwoBytes();\r\n    frame.top = byteStream.nextTwoBytes();\r\n    frame.width = byteStream.nextTwoBytes();\r\n    frame.height = byteStream.nextTwoBytes();\r\n    const packedByte = byteStream.nextByte(), localColorTableFlag = (packedByte & 0x80) === 0x80, interlacedFlag = (packedByte & 0x40) === 0x40;\r\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\r\n    frame.reserved = (packedByte & 0x18) >>> 3;\r\n    const localColorCount = 1 << ((packedByte & 7) + 1);\r\n    if (localColorTableFlag) {\r\n        frame.localColorTable = parseColorTable(byteStream, localColorCount);\r\n    }\r\n    const getColor = (index) => {\r\n        const { r, g, b } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\r\n        return { r, g, b, a: index === getTransparencyIndex(null) ? (avgAlpha ? ~~((r + g + b) / 3) : 0) : 255 };\r\n    };\r\n    const image = (() => {\r\n        try {\r\n            return new ImageData(frame.width, frame.height, { colorSpace: \"srgb\" });\r\n        }\r\n        catch (error) {\r\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\r\n                return null;\r\n            }\r\n            throw error;\r\n        }\r\n    })();\r\n    if (image == null) {\r\n        throw new EvalError(\"GIF frame size is to large\");\r\n    }\r\n    const minCodeSize = byteStream.nextByte(), imageData = byteStream.readSubBlocksBin(), clearCode = 1 << minCodeSize;\r\n    const readBits = (pos, len) => {\r\n        const bytePos = pos >>> 3, bitPos = pos & 7;\r\n        return (((imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16)) &\r\n            (((1 << len) - 1) << bitPos)) >>>\r\n            bitPos);\r\n    };\r\n    if (interlacedFlag) {\r\n        for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0; pass < 4; pass++) {\r\n            if (InterlaceOffsets[pass] < frame.height) {\r\n                for (let pixelPos = 0, lineIndex = 0;;) {\r\n                    const last = code;\r\n                    code = readBits(pos, size);\r\n                    pos += size + 1;\r\n                    if (code === clearCode) {\r\n                        size = minCodeSize + 1;\r\n                        dic.length = clearCode + 2;\r\n                        for (let i = 0; i < dic.length; i++) {\r\n                            dic[i] = i < clearCode ? [i] : [];\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (code >= dic.length) {\r\n                            dic.push(dic[last].concat(dic[last][0]));\r\n                        }\r\n                        else if (last !== clearCode) {\r\n                            dic.push(dic[last].concat(dic[code][0]));\r\n                        }\r\n                        for (let i = 0; i < dic[code].length; i++) {\r\n                            const { r, g, b, a } = getColor(dic[code][i]);\r\n                            image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width +\r\n                                InterlaceSteps[pass] * lineIndex +\r\n                                (pixelPos % (frame.width * 4)));\r\n                            pixelPos += 4;\r\n                        }\r\n                        if (dic.length === 1 << size && size < 0xc) {\r\n                            size++;\r\n                        }\r\n                    }\r\n                    if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\r\n                        lineIndex++;\r\n                        if (InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            progressCallback?.(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\r\n        }\r\n        frame.image = image;\r\n        frame.bitmap = await createImageBitmap(image);\r\n    }\r\n    else {\r\n        for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pixelPos = -4;;) {\r\n            const last = code;\r\n            code = readBits(pos, size);\r\n            pos += size;\r\n            if (code === clearCode) {\r\n                size = minCodeSize + 1;\r\n                dic.length = clearCode + 2;\r\n                for (let i = 0; i < dic.length; i++) {\r\n                    dic[i] = i < clearCode ? [i] : [];\r\n                }\r\n            }\r\n            else {\r\n                if (code === clearCode + 1) {\r\n                    break;\r\n                }\r\n                if (code >= dic.length) {\r\n                    dic.push(dic[last].concat(dic[last][0]));\r\n                }\r\n                else if (last !== clearCode) {\r\n                    dic.push(dic[last].concat(dic[code][0]));\r\n                }\r\n                for (let i = 0; i < dic[code].length; i++) {\r\n                    const { r, g, b, a } = getColor(dic[code][i]);\r\n                    image.data.set([r, g, b, a], (pixelPos += 4));\r\n                }\r\n                if (dic.length >= 1 << size && size < 0xc) {\r\n                    size++;\r\n                }\r\n            }\r\n        }\r\n        frame.image = image;\r\n        frame.bitmap = await createImageBitmap(image);\r\n        progressCallback?.((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\r\n    }\r\n}\r\nasync function parseBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\r\n    switch (byteStream.nextByte()) {\r\n        case 59:\r\n            return true;\r\n        case 44:\r\n            await parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\r\n            break;\r\n        case 33:\r\n            await parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\r\n            break;\r\n        default:\r\n            throw new EvalError(\"undefined block found\");\r\n    }\r\n    return false;\r\n}\r\nexport function getGIFLoopAmount(gif) {\r\n    for (const extension of gif.applicationExtensions) {\r\n        if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\r\n            continue;\r\n        }\r\n        return extension.data[1] + (extension.data[2] << 8);\r\n    }\r\n    return NaN;\r\n}\r\nexport async function decodeGIF(gifURL, progressCallback, avgAlpha) {\r\n    if (!avgAlpha)\r\n        avgAlpha = false;\r\n    const res = await fetch(gifURL);\r\n    if (!res.ok && res.status === 404) {\r\n        throw new EvalError(\"file not found\");\r\n    }\r\n    const buffer = await res.arrayBuffer();\r\n    const gif = {\r\n        width: 0,\r\n        height: 0,\r\n        totalTime: 0,\r\n        colorRes: 0,\r\n        pixelAspectRatio: 0,\r\n        frames: [],\r\n        sortFlag: false,\r\n        globalColorTable: [],\r\n        backgroundImage: new ImageData(1, 1, { colorSpace: \"srgb\" }),\r\n        comments: [],\r\n        applicationExtensions: [],\r\n    }, byteStream = new ByteStream(new Uint8ClampedArray(buffer));\r\n    if (byteStream.getString(6) !== \"GIF89a\") {\r\n        throw new Error(\"not a supported GIF file\");\r\n    }\r\n    gif.width = byteStream.nextTwoBytes();\r\n    gif.height = byteStream.nextTwoBytes();\r\n    const packedByte = byteStream.nextByte(), globalColorTableFlag = (packedByte & 0x80) === 0x80;\r\n    gif.colorRes = (packedByte & 0x70) >>> 4;\r\n    gif.sortFlag = (packedByte & 8) === 8;\r\n    const globalColorCount = 1 << ((packedByte & 7) + 1), backgroundColorIndex = byteStream.nextByte();\r\n    gif.pixelAspectRatio = byteStream.nextByte();\r\n    if (gif.pixelAspectRatio !== 0) {\r\n        gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\r\n    }\r\n    if (globalColorTableFlag) {\r\n        gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\r\n    }\r\n    const backgroundImage = (() => {\r\n        try {\r\n            return new ImageData(gif.width, gif.height, { colorSpace: \"srgb\" });\r\n        }\r\n        catch (error) {\r\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\r\n                return null;\r\n            }\r\n            throw error;\r\n        }\r\n    })();\r\n    if (backgroundImage == null) {\r\n        throw new Error(\"GIF frame size is to large\");\r\n    }\r\n    const { r, g, b } = gif.globalColorTable[backgroundColorIndex];\r\n    backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\r\n    for (let i = 4; i < backgroundImage.data.length; i *= 2) {\r\n        backgroundImage.data.copyWithin(i, 0, i);\r\n    }\r\n    gif.backgroundImage = backgroundImage;\r\n    let frameIndex = -1, incrementFrameIndex = true, transparencyIndex = -1;\r\n    const getframeIndex = (increment) => {\r\n        if (increment) {\r\n            incrementFrameIndex = true;\r\n        }\r\n        return frameIndex;\r\n    };\r\n    const getTransparencyIndex = (newValue) => {\r\n        if (newValue != null) {\r\n            transparencyIndex = newValue;\r\n        }\r\n        return transparencyIndex;\r\n    };\r\n    try {\r\n        do {\r\n            if (incrementFrameIndex) {\r\n                gif.frames.push({\r\n                    left: 0,\r\n                    top: 0,\r\n                    width: 0,\r\n                    height: 0,\r\n                    disposalMethod: 0,\r\n                    image: new ImageData(1, 1, { colorSpace: \"srgb\" }),\r\n                    plainTextData: null,\r\n                    userInputDelayFlag: false,\r\n                    delayTime: 0,\r\n                    sortFlag: false,\r\n                    localColorTable: [],\r\n                    reserved: 0,\r\n                    GCreserved: 0,\r\n                });\r\n                frameIndex++;\r\n                transparencyIndex = -1;\r\n                incrementFrameIndex = false;\r\n            }\r\n        } while (!(await parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback)));\r\n        gif.frames.length--;\r\n        for (const frame of gif.frames) {\r\n            if (frame.userInputDelayFlag && frame.delayTime === 0) {\r\n                gif.totalTime = Infinity;\r\n                break;\r\n            }\r\n            gif.totalTime += frame.delayTime;\r\n        }\r\n        return gif;\r\n    }\r\n    catch (error) {\r\n        if (error instanceof EvalError) {\r\n            throw new Error(`error while parsing frame ${frameIndex} \"${error.message}\"`);\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}